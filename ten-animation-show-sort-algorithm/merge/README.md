归并排序

5.1 算法步骤

申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；

设定两个指针，最初位置分别为两个已经排序序列的起始位置；

比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；

重复步骤 3 直到某一指针达到序列尾；

将另一序列剩下的所有元素直接复制到合并序列尾。

- 先自顶向下细分，再自底向上合并
- 相比排序，对有序的序列合并是很快的

>首先，科学家们发现，如果我们把全班同学分成两组，分别排序，那么从每一组中挑选出一个最大的，就能省去一半的相互比较时间。于是他们就先将整个班级一分为二，先分别进行排序，再把两个排好序的组，合并成为一个有序的序列。相比排序，对有序的序列合并是很快的。归并排序这个词就是这么来的。这样做大约可以节省一半时间。当然，我们在前面也讲过，节省一半时间意义不大，但是别着急，因为对一个班级分出来的两个小组，排序时也可以采用上述技巧。
>第二步，就是对两个组的排序。显然我们不应该再用冒泡排序。聪明一点的人马上会想到，既然能分成两组，就能把每个小组再分为两组，即分成四组，重复上面的算法，分别排序再合并。这样就能省3/4的时间。
>再接下来，四组可以分为八组，能省7/8的时间，八组可以分为十六组，时间就不断省得越来越多。分到最后每个小组只剩下两个人的时候，其实就不用排序了，只要比较一次大小即可。这种方法其实可以理解为两个过程，先是自顶向下细分，再自底向上合并。那么这种算法的复杂度等于多少呢？它相当于N乘以log（N），log（N）就是N的对数函数，大家不必在意N乘以log（N）是什么东西，只要记住它和N平方不一样，而且这个复杂度比前面的N平方小很多就行了
