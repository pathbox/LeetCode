算法步骤

从数列中挑出一个元素，称为 “基准”（pivot）;

重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；

递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

- 一般情况，快速排序是世界上最快的排序算法
- 选定一个枢值(基准值)
- Nlog(N) 是排序算法的极限

>是由英国计算机科学家托尼·霍尔（Tony Hoare）于1959年想到的，1961年发表的，这个算法也成了今天世界计算机产业中使用最多的排序算法，霍尔因此获得了爵士头衔，也成为第一个获得这种头衔的科学家。那么快速排序为什么快呢？原因很简单，它还是强调少做事情，其原理大致是这样的：

>首先，对于一大堆无序的数字，从中随机挑选一个，比如是53，这个被随机选上的数字被称为枢值（枢纽的枢），接下来，将所有要排序的数字分成两部分，第一部分是大于等于枢值53的，第二部分是小于枢值53的。在第一步完成后，一大堆无序的数字就变得稍微有序一点了。

>第二步，从上面得到的两堆数字，分别采用第一步的方法各自再找一个枢值。对于第一堆，由于所有的数字都比53大，至少也等于53，因此，第二次随机挑选的枢值肯定是一个大于53的数字，比如79；类似地，对于第二堆，由于所有的数字都小于53，因此第二次随机挑选的枢值肯定小于它，比如4。接下来，再把两堆数字各自分成大于等于相应枢值的数字序列，以及小于枢值的数字序列。这样做下来，原来的一大堆数就变成了四小堆，它们分别是小于4的数字，介于4到53之间的，介于53到79之间的，以及大于或等于79的。

>再接下来，用同样的方法，四堆变八堆，八堆变十六堆，很快所有的数字就排好序了。

>这种算法通常情况下复杂度也是N乘以log（N），和昨天介绍的归并排序相同。根据计算机科学的标准，它们同样好，不过在工程上，快速排序算法一般情况下比归并排序快两倍，因此在工程上还是有意义的。这也是为什么很多人用它的原因。至于为什么快速排序能够更快一些呢？这可以在计算机科学上证明，不过为了方便理解，我打一个比方你就明白了。

### 三种排序之间的通俗比较，为什么快排最快
>假如有一个学区，里面有20000名高中学生，如果让大家到一个超级大的学校上大课，再从中挑出学生中的尖子，效率一定高不了。这就相当于是昨天一开始讲的冒泡排序，每一个人都要和所有人去比。如果我们把2万人放到10所学校中，每所学校只有两千人，从各个学校先各自挑出学习尖子，再彼此进行比较，这就有效得多了。这就是昨天说的归并排序原理。如果我们先划出几个分数线，根据个人成绩的高低把20000个学生分到十所学校去，第一所学校里的学生成绩最好，第十所最差，再找出学习尖子，那就容易了，工作量最小，这就是快速排序的原理，也是快速排序比昨天讲的归并排序快的原因。
